#include<iostream>
using namespace std;

int near2power(int a);

int main()
{
    cout << near2power(9);
}

//把最左边的1的右边全部搞成1
int near2power(int a)
{
    if(a <= 0) return 1;

    a--; //防止本身就是2的幂
    a |= a >> 1;
    a |= a >> 2;
    a |= a >> 4;
    a |= a >> 8;
    a |= a >> 16;//为什么移动16位， 1.乘2就是32， 2. 如果是15位的话， 最后一位会剩下？
    // 0100 0000 0000 0000 0000 0000 0000 0001 
    // 为什么要1， 2， 4... 因为这样可以保证严丝合缝
    return a + 1;
    // a =     1100 0100
    //a - 1 =  1100 0011
    //         1110 0011
    //         1111 1111

    // b =     1000 0001
    // b - 1 = 1000 0000
    //         1100 0000
    //         1111 0000
    //         1111 1111

}